<!--
    Relative paths assume component is being run from inside an app or another component, where dependencies are flat
    siblings. When this component is run from its own repo (e.g. ui tests, examples), we assume the server is started with
    'grunt depserve' (or similar server setup) to enable correct finding of bower dependencies for local runs
-->
<link rel="import" href="bower_components/polymer/polymer.html" />
<link rel="import" href="px-sb-list.html" />
<link rel="import" href="bower_components/px-polymer-font-awesome/polymer-font-awesome.html" />
<!--
Element providing sidebar for the predix ui website.

##### Usage

```

```

@element px-sb
@blurb Element providing sidebar for the predix ui website.
@homepage index.html
@demo demo.html
-->
<link rel="import" href="css/px-sb-styles.html">

<dom-module id="px-sb">
  <template>
    <style include="px-sb-styles"></style>
    <style include="px-theme-styles"></style>
    <div class="search">
      <div class="input">
        <input id="searchInput" type="text" value="{{searchKeyword::input}}" placeholder="Type In A Search Term...">
      </div>
      <div class="icon"><iron-icon icon="fa:fa-times" class="fa-x" on-click="_resetSearch" id="searchIcon"></iron-icon></div>
    </div>
    <ul style="margin-top:40px;">
      <template is="dom-repeat" items="{{nav}}">
        <px-sb-list nav-item="[[item]]" selected="{{selected}}" search-keyword="{{searchKeyword}}" item-path="[[index]].links" selected-elem="{{selectedElem}}"></px-sb-list>
      </template>
    </ul>
  </template>
</dom-module>
<script>
  Polymer({
    is: 'px-sb',
    attached: function() {
      //we call this to find out if there a component is specified in the url
      this.getRoute();
      //and configure a listener that listens to popstate - which is activated by the back and forward buttons.
      // we listen to these to make sure the left nav is in sync with the url, and with the content window.
      window.addEventListener('popstate', this._popStateChanged.bind(this));
    },
    /*
    * Called when the X is pressed in the search bar, this method resets the searchKeyword property and
    * resets the selected property, in case there was a selection while the nav was filtered through search.
    *
    * @method _resetSearch
     */
    _resetSearch: function() {
      this.set('searchKeyword','');
      this.$.searchInput.focus();

      //this is async'd to give the nav time to rebuild
      this.async(function() {

        var name = this.selectedElem.getAttribute('data-name'),
            type = this.selectedElem.getAttribute('data-type'),
            newSelectedPath = this._findItemPath(this.nav, name),
            oldPath = this._findItemPath(this.nav, this.previousSelectedName),
            obj = {};

            obj.detail = {};
            obj.detail.selectedItem = name;
            obj.detail.itemType = type;
            obj.detail.path = newSelectedPath;

        // we send a newValue and an oldValue to _selectedChange first, TO "zero out" the oldVal portion of _selectedChange
        this._selectedChange('nav.' + newSelectedPath, 'nav.' + oldPath);

        this._launchSelectedChange(obj);

        //let's find the trail for the selected element, and make sure all the menus on the path to it are opened.
        var trail = this._findItemTrail(this.nav, name);
        this._changeOpenedProperty(trail);

        //and reset everything so it's ready for next time.
        this.set('selectedElem',{});
        this.set('previousSelectedName', '');

      },50);
    },
    /*
    *
    * recuresively search the model for the item passed, and
    * returns an array that represents the path to the item,
    *
    * Also sets the selected property to the path found, in string notation - for example, 0.links.3.links.3
    *
    * @method _findItemTrail
    * @prop navArr {Object}
    * @prop selectedItemEvt {object}
    * @prop path {String}
     */
    _findItemTrail: function(navArr, selectedItem, path) {
      var i,
          len,
          oldPath,
          arr;

      for (i = 0, len = navArr.length; i < len; i++) {
        if (navArr[i].links) {
          oldPath = path;
          path = (path)?path:'';
          path += i.toString() + '.links.';

          //this will return null when it can't find anything, but if it does find something, we grab the array its returned, push that into another array, and return that.
          arr = this._findItemTrail(navArr[i].links, selectedItem, path);
          if (arr !== null) {
            navArr[i].path = path.substr(0,path.length - 7);
            arr.push(navArr[i]);
            //this is the final return, after the recursion is done
            return arr;
          } else {
            //we found nothing, we don't need this path. reset.
            path = oldPath;
          }
        }

        if (navArr[i].repoName === selectedItem) {
          path += i.toString();
          //this.set('nav.' + path +'.selected',true);
          this.set('selected', 'nav.' + path);
          navArr[i].path = path;
          //this will return into the recursion.
          return [navArr[i]];
        }
      }
      //this will only hit if we didn't find anything in the recursive search.
      return null;
    },
    /*
    *
    * recuresively search the model for the item passed, and
    * returns an path that represents the path to the item in string notation - for example, 0.links.3.links.3
    *
    * @method _findItemPath
    * @prop navArr {Object}
    * @prop selectedItem {String}
    * @prop path {String}
     */
    _findItemPath: function(navArr, selectedItem, path) {
      var i,
          len,
          foundPath;

      for (i = 0, len = navArr.length; i < len; i++) {
        if (navArr[i].links) {
          var oldPath = path;
          path = (path)?path:'';
          path += i.toString() + '.links.';

          foundPath = this._findItemPath(navArr[i].links, selectedItem, path);
          if (foundPath === null) {
            //we found nothing, we don't need this path. reset.
            path = oldPath;
          } else {
            //this is the final return
            return foundPath;
          }
        }

        if (navArr[i].repoName === selectedItem) {
          //this will return into the recursion.
          return path + i.toString();
        }
      }
      //this will only hit if we didn't find anything in the recursive search.
      return null;
    },
    /*
    *
    * loops through the trail (array) given to it, and sets the opened property on each item
    * @method _changeOpenedProperty
     */
    _changeOpenedProperty: function(trail) {
      if (typeof trail === 'string') {
        this.set('nav.' + trail + '.opened', true);
      } else {
        if (trail && trail.length) {
          trail.forEach(function(item) {
            this.set('nav.' + item.path + '.opened', true);
          }.bind(this));
        }
      }
    },
    /*
    *
    * sets the selected property to the path specified in the event.
    * @method _setSelected
     */
    _setSelected: function(evt) {
      if (evt.detail.path) {
        this.set('selected', 'nav.'+ evt.detail.path);
      }
    },
    /*
    *
    * Called when the "px-sb-list-selected-item-changed" event is fired, This method sets the name and type properties of the selected item on px-sb,
    * sets the route (changes iframe url and window.history), removes all the opened=true properties on the arrows, finds the trail from the selected item up to the root,
    * and sets opened=true on the correct arrows, and last but not least, sets the item as the selected item.
    * @method _launchSelectedChange
     */
    _launchSelectedChange: function(selectedItem) {
      var item = selectedItem.detail;
      this.set('name', item.selectedItem);
      this.set('type', item.itemType);
      //load the correct url into the iframe, and set the window.history change.
      this._setRoute(item.selectedItem, item.itemType, item.path);
      //the trail is path from the top menu to the selected item - needed so we can set opened=true on the arrow that are part of the path.
      //and make sure to change our selected property.
      this._setSelected(selectedItem);
    },

    listeners: {
      'px-sb-list-selected-item-changed' : '_launchSelectedChange'
    },
    /*
    *
    * Pop state is called on a click on the back or forward button on the browser.
    * Since we are changing the window.history object, this method ensures that when those buttons are clicked, the behaviour is as expected.
    * @method _popStateChanged
    * @prop e {Event}
     */
    _popStateChanged: function(e) {
      //set up the object with the correct info and property that _launchSelectedChange expectes, emulating the event structure.
      var obj = {};
      obj.detail = {};
      obj.detail.selectedItem = e.state.name;
      obj.detail.itemType = e.state.type;
      obj.detail.path = e.state.path;
      this._launchSelectedChange(obj);
      // we don't want the back or forward button to actually do their intended action.
      e.preventDefault();
    },
    /*
    *
    * Called when the search Keyword is changed to call the filter on the nav.
    * To ensure we don't do this on every single key down, we have a debounce in place.
    * @method _computedNav
    * @prop navArr {Object}
    * @prop searchKeyword {String}
     */
    _computedNav: function(navArr, searchKeyword) {
      //if there's no searchKeyword, nothing needs to be rebuild. return the existing nav.
      if (searchKeyword === '') {
        this.set('nav', this.initialNav);
        return;
      }

      this.debounce('navBuild', function() {
        //if the user has an item selected, types in a search, and then clicks on an item in the filtered list, and THEN hits the X, we need to know the
        //name of the item that was selected before the search, so we can remove the selected property on it. we can't remove it automatically, since another scenario is for
        //the user to have a selected item, search, NOT select anything, and click X, in which point we want the previously selected one to still be selected.
        this.set('previousSelectedName', this.name);
        //call the filter with the search keyword
        this.set('nav', this._buildNav(navArr, searchKeyword));
      }, 150);
    },
    /*
    *
    * Called when a search keyword is entered, and builds (and returns) a new nav Object that only contains the search query.
    * @_buildNav
    * @prop navArr {Object}
    * @prop searchKeyword {String}
     */
    _buildNav: function(navArr, searchKeyword) {
      var foundItems = [];
      for (var i = 0, len=navArr.length; i < len; i++) {
        //build our initial object and populate it.
        var currentObj = {};
        currentObj.linkText = navArr[i].linkText;
        currentObj.dataType = navArr[i].dataType;
        currentObj.repoName = navArr[i].repoName;
        currentObj.selected = navArr[i].selected;
        currentObj.opened = true;
        //if the item has links (ie children), recurse and if another array with links is returned, insert that into the object.
        if (navArr[i].links) {
          var tempArr = this._buildNav(navArr[i].links, searchKeyword);
          if (tempArr.length) {
            currentObj['links'] = tempArr;
          }
        }
        //lowercase both the search keyword, and link text, and compare - if there's a match, push it into the array.
        if (navArr[i].linkText.toLowerCase().indexOf(searchKeyword.toLowerCase()) !== -1 || currentObj.links) {
          foundItems.push(currentObj);
        }
      }
      //returns a rebuilt, filtered nav
      return foundItems;
    },
    /*
    *
    * called when the searchKeyword is changed, and sets off the nav rebuild process.
    * @method _callNavRebuild
     */
    _callNavRebuild: function() {
      if (this.searchKeyword) {
        this.set('nav', this.nav);
      }
    },
    /*
    * calculates the appropriate URL and returns it if it's local. if it's external, opens a new window, and returns false.
    * method _getWantedFrame
     */
    _getWantedFrame: function(name, type) {
      if  (type === "external") {
        window.open(this.types.external(name), '_blank');
        return false;
      } else if (name && type) {
        return this.types[type](name);
      }
    },
    /*
    * called on initial load, in case there is a component specified in the url.
    * changes the iframe url, and the window.history.state
     */
    _setRoute: function(name, type, path) {

      this._changeIframeUrl(name, type);

      window.history.pushState({name: name, type:type, path: path},'','?show=' + name + '&type=' + type);
    },
    getRoute: function() {
      var name = this._getURLParameter('show') || null,
          type = this._getURLParameter('type') || null;

      this.set('name', this._getURLParameter('show') || null);
      this.set('type', this._getURLParameter('type') || null);
      //TODO wrap this next one in an if statement, comparing the existing url to the new one, and only calling this on different URLs
      this._changeIframeUrl(this.name, this.type);

      if (this.name) {
        //find the trail
        var trail = this._findItemTrail(this.nav, this.name),
            path;

        //the first item from the trail is always item itself. now we have the path :)
        if (trail.length) {
          path = trail[0].path;
        }
    //using the trail, we set the opened=true properties on the correct arrows on initial load. the listener in sb-list does it on click from now on, and it also happens on searchKeyword reset.
    this._changeOpenedProperty(trail);

    this.fire('px-sb-list-selected-item-changed', {selectedItem: this.name, itemType: this.type, path: path});

      }
    },
    /*
    * This event is fired when the iframeUrl needs to change. it contains: url, external, name and type.
    * @event px-sb-list-iframe-url-change
     */
    /*
    *
    * this fires off the px-sb-list-iframe-url-change event which is picked up in the index.html page.
    * @method _changeIframeUrl
     */
    _changeIframeUrl: function(name, type) {
      var iframeUrl = this._getWantedFrame(name, type),
          external = (type === 'external');
      this.fire('px-sb-list-iframe-url-change', {url: iframeUrl, external: external, name: name, type: type});
    },
    /*
    *
    * this method parses the url and looks for parameters.
    *
    * @method _getURLParameter
     */
    _getURLParameter: function(sParam) {
      var sPageURL = window.location.search.substring(1),
          sURLVariables = sPageURL.split('&'),
          i,
          len = sURLVariables.length,
          sParameterName;

      for (i = 0; i < len; i++) {
        sParameterName = sURLVariables[i].split('=');
        if (sParameterName[0] === sParam) {
          return sParameterName[1];
        }
      }
    },
    /*
    * Called as an observer on selected, expects a newVal and oldVal, and uses both of those to set the correct state - true or false.
    * the template is watching the .selected property, and will pick this change up, since we are using the specific path to notify polymer of the change.
    * once the change is picked up, the selected class is automatically added or remove the correct item.
    * @method _selectedChange
     */
    _selectedChange: function(newVal, oldVal) {
      var newPath = newVal  + '.selected',
          oldPath = oldVal  + '.selected';

      if (oldVal) {
        this.set(oldPath, false);
      }

      this.set(newPath, true);
    },
    observers: ['_computedNav(initialNav, searchKeyword)'],
    properties: {
      previousSelected:
      {
        type: String,
        value: ''
      },
      selectedElem: {
        type: Object,
        notify: true
      },
      types: {
        type: Object,
        value: {
          "component" : function(name) {
            return "https://predixdev.github.io/" + name + "/" + name + "/";
          },
          "local": function(name) {
            return name + ".html";
          },
          "external" : function(name) {
            return "https://github.com/predixdev/" + name;
          },
          "design": function(name) {
            return "https://predixdev.github.io/" + name + "/" + name + "/";
          },
          "home" : function() {
            return 'landing_page.html';
          }
        }
      },
      openedItemsArr: {
        type: Array,
        value: function() {return[];}
      },
      selected: {
        type: String,
        notify: true,
        observer: '_selectedChange'
      },
      opened: {
        type: Array,
        value: function(){return [];}
      },
      searchKeyword: {
        type: String,
        value: '',
        notify:true,
        observer: '_callNavRebuild'
      },
      nav: {
        type: Object,
        notify: true
      },
      initialNav: {
        type: Array,
        value: function() {return [];}
      }
    }
  });
</script>
